---
title: Процедура участия в разработке репозиториев документации по .NET
description: В этой статье описывается процедура участия в разработке репозиториев документации по .NET. Вы узнаете об используемых репозиториях, процессе организации содержимого и политиках управления примерами кода и другими ресурсами.
ms.date: 11/07/2018
ms.openlocfilehash: 121f6c885ef6d292968e5bb3961cae8e9c22942b
ms.sourcegitcommit: 8e897e90268a8a87dc4b97d7c28d22ed5950c8d9
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/29/2019
ms.locfileid: "58637513"
---
# <a name="process-for-contributing-to-net-docs"></a>Процесс участия в составлении документации по .NET

Мы ценим вклад сообщества в составление документации. Ниже приводятся правила, которых следует придерживаться при составлении документации по .NET.

- **НЕ** удивляйте нас огромными запросами на вытягивание. Лучше сообщите о проблеме и начните обсуждение, чтобы мы согласовали направление, прежде чем вы потратите свое время.
- **Следуйте** этим инструкциям и [рекомендациям по стилистике](dotnet-voice-tone.md).
- **Используйте** файл [шаблона](dotnet-style-guide.md) в качестве отправной точки.
- **Создайте** отдельную ветвь в вилке, прежде чем приступить к работе над статьями.
- **Следуйте** [рабочему процессу GitHub](https://guides.github.com/introduction/flow/).
- **Делайте записи** в блоге или Twitter (или на других платформах) о своем вкладе.

Эти рекомендации облегчат работу и вам, и нам.

## <a name="make-a-contribution-to-net-docs"></a>Участие в составлении документации по .NET

**Шаг 1:** Пропустите этот шаг, если собираетесь внести незначительные изменения. Если вы хотите написать новую статью или существенно исправить уже опубликованную, откройте [проблему](https://github.com/dotnet/docs/issues) с описанием ваших намерений.

Содержимое в папке **docs** разбито на разделы в соответствии с оглавлением. Найдите тему по оглавлению. Получите обратную связь о своем предложении.

или

Выберите существующую проблему, в решении которой может участвовать сообщество. В разделе [Проекты для участников сообщества .NET](https://github.com/dotnet/docs/projects/35) представлено множество нерешенных проблем для сообщества. Вы можете выбрать интересующую вас проблему в следующих категориях:

- **Обслуживание**. В эту категорию входят довольно простые проблемы, например исправление нерабочих или некорректных ссылок, добавление отсутствующих примеров кода или решение проблем с ограниченным содержимым. В некоторых случаях эти проблемы затрагивают большое количество файлов. В такой ситуации сообщите нам, над чем вы хотите поработать, прежде чем начать. Напишите комментарий к проблеме, чтобы уведомить нас, что работаете над ней.

- **Обновление содержимого**. Поскольку объем документации очень большой, содержимое часто устаревает и требует пересмотра. Кроме того по разным причинам одно и то же содержимое может быть представлено дважды, а то и трижды. При обновлении содержимого следует убедиться, что отдельные темы не потеряли актуальность, и рекомендуем пересматривать содержимое в специальной области, чтобы избежать повторения и гарантировать, что все уникальное содержимое хранится в небольшом наборе документации.

- **Создание нового содержимого**. Если вы хотите написать свою статью, в проблемах найдите тему, которой нам не хватает в документации. Не забудьте предварительно сообщить нам, что собираетесь работать над этой темой. Если вы хотите написать статью на тему, которой здесь нет, откройте проблему.

Изучите список [открытых проблем](https://github.com/dotnet/docs/issues) и работайте над теми, которые вас интересуют. Проблемы, требующие вклада сообщества, помечаются меткой [up-for-grabs](https://github.com/dotnet/docs/labels/up-for-grabs) (доступно для всех желающих). Обычно они почти не требуют контекста и подходят для начинающих. Опытные участники сообщества могут работать над любыми интересующими их проблемами. Когда найдете проблему, спросите в комментариях, открыта ли она.

Выбрав задачу, следуйте руководству [по началу работы](get-started-setup-github.md), чтобы создать учетную запись GitHub и настроить среду.

**Шаг 2:** Создайте вилку в репозиториях `/dotnet/docs`, `dotnet/samples`, `dotnet/dotnet-api-docs`, `dotnet/roslyn-api-docs` или `dotnet/ml-api-docs` и создайте ветвь для своих изменений.

Если это незначительные изменения, см. инструкции по редактированию в GitHub на [домашней странице](index.md#quick-edits-to-existing-documents) руководства для участников.

**Шаг 3:** Внесите изменения в новой ветви.

Если это новая тема, используйте [файл шаблона](dotnet-style-guide.md) в качестве отправной точки. Он содержит рекомендации по написанию и разъяснения по метаданным, необходимым для каждой статьи, например информация об авторе.

Перейдите в папку, руководствуясь оглавлением, как описано в шаге 1. Папка содержит файлы Markdown для всех статей в этом разделе. При необходимости создайте новую папку, чтобы поместить в нее файлы для вашей статьи. Основная статья этого раздела называется *index.md*. Изображения и другие статические ресурсы размещайте во вложенной папке **media** внутри папки с вашей статьей. Создайте эту папку, если она еще не существует. В папке **media** создайте вложенную папку с названием статьи (за исключением файла index). Пример кода должен находиться в репозитории `dotnet/samples`, как описано в статье о [примерах](#contributing-to-samples).

Обязательно соблюдайте синтаксис Markdown. Примеры смотрите в [руководстве по шаблонам и Markdown](dotnet-style-guide.md).

## <a name="example-structure"></a>Пример структуры

    docs
      /about
      /core
        /porting
          porting-overview.md
          /media
            /porting-overview
                portability_report.png

**Шаг 4:** Отправьте запрос на включение внесенных изменений из вашей ветви в главную ветвь.

> [!IMPORTANT]
> Функция [автоматизации комментариев](how-to-write-workflows-major.md#review-and-sign-off) пока не доступна в репозиториях документации по .NET. Члены команды документации по .NET рассмотрят ваши запросы на вытягивание и выполнят слияние.

Каждый запрос на вытягивание обычно относится к одной проблеме. Запрос на вытягивание может менять один или несколько файлов. Если вы работаете с несколькими исправлениями в разных файлах, создайте отдельные запросы на вытягивание. Если вы создаете примеры и обновляете Markdown, создайте отдельный запрос на вытягивание для примеров.

Если ваш запрос на вытягивание исправляет существующую проблему, добавьте ключевое слово `Fixes #Issue_Number` в сообщение о фиксации или описание запроса на вытягивание. Таким образом проблема будет автоматически закрыта при слиянии запроса на вытягивание. Дополнительные сведения см. в разделе [Закрытие проблем с помощью сообщений о фиксации](https://help.github.com/articles/closing-issues-via-commit-messages/).

Команда по .NET рассмотрит ваш запрос на вытягивание и сообщит вам, если нужны дополнительные изменения для его одобрения.

**Шаг 5:** Внесите необходимые изменения в вашу ветвь по рекомендациям команды.

Наша команда объединит ваш запрос на вытягивание с главной ветвью, когда вы учтете их замечания и изменения будут одобрены.

Мы регулярно отправляем все фиксации из главной ветви в ветвь в реальном времени, где вы сможете увидеть свой вклад: https://docs.microsoft.com/dotnet/. Обычно мы публикуем изменения ежедневно в течение рабочей недели. Во время обслуживания публикация может быть отложена на несколько дней.

## <a name="contributing-to-samples"></a>Участие в создании примеров

Репозиторий [dotnet/samples](https://github.com/dotnet/samples) содержит все примеры кода, относящиеся к любой теме в документации по .NET. Существует несколько разных проектов, разделенных по вложенным папкам. Эти вложенные папки организованы так же, как документация по .NET.

Мы делаем следующее различие для кода, который существует в нашем репозитории:

- Примеры: читатели могут загружать и запускать примеры. Все примеры должны быть завершенными приложениями или библиотеками. Если пример создает библиотеку, он должен включать модульные тесты или приложение, где читатели могут запустить код. Часто они используют несколько технологий, функций или инструментов. Файл readme.md для каждого примера ссылается на статью, чтобы можно было узнать больше о понятиях, приведенных в примерах.
- Фрагменты кода: иллюстрируют ограниченную концепцию или задачу. Они компилируются, но не могут служить полноценным приложением. Они будут запускаться, но не являются примерами приложения для типичного сценария. Они должны быть как можно меньше, чтобы иллюстрировать только одну концепцию или функцию. Это должен быть максимум один экран кода.

Все коды размещены в репозитории [dotnet/samples](https://github.com/dotnet/samples). Мы стараемся создать модель, в которой структура папки с примерами будет соответствовать структуре папки с документами. Мы соблюдаем следующие стандарты:

- Папка с *фрагментами кода* верхнего уровня содержит фрагменты для небольших примеров, сосредоточенных на одной концепции.
- Примеры справки по API размещаются в папке по следующей схеме: *snippets/\<язык>/api/\<пространство_имен>/\<имя_api>*.
- Другие папки верхнего уровня соответствуют папкам верхнего уровня в репозиторий *docs*. Например, репозиторий документации содержит папку *machine-learning/tutorials*, а примеры для руководств по машинному обучению находятся в папке *samples/machine-learning/tutorials*.

Кроме того, все примеры в папках *core* и *standard* должны компилироваться и запускаться на всех платформах, поддерживаемых .NET Core. Наша система непрерывной интеграции этого требует. В папке верхнего уровня *framework* содержатся примеры, которые компилируются и проверяются только в Windows.

Примеры проектов должны компилироваться и запускаться на самом широком наборе платформ, возможном для конкретного примера. На практике это означает сборку консольных приложений на базе .NET Core по возможности. Примеры, относящиеся к веб-платформе или платформе пользовательского интерфейса, должны добавлять эти инструменты при необходимости. Примеры включают веб-приложения, мобильные приложения, приложения WPF или WinForms и т. д.

Мы работаем над системой непрерывной интеграции для всего кода. Если вы обновляете примеры, убедитесь, что каждое обновление является частью компилируемого проекта. В идеале следует добавить тесты для проверки примеров.

Каждый созданный пример должен содержать файл *readme.md*. В файле должно приводиться краткое описание примера (один–два абзаца). Из файла *readme.md* читатели должны понять, что они узнают из этого примера. В файле *readme.md* должна быть ссылка на документ на [сайте документации по .NET](https://docs.microsoft.com/dotnet/welcome). Чтобы определить, где будет расположен определенный файл в репозитории на этом сайте, замените `/docs` в репозитории на `http://docs.microsoft.com/dotnet`.

Ваша статья будет содержать ссылки на этот пример. Указывайте прямую ссылку на папку с примером на GitHub.

### <a name="writing-a-new-snippet-or-sample"></a>Написание фрагмента или примера кода

1. Ваш пример **должен быть частью компилируемого проекта**. По возможности проекты должны компилироваться на всех платформах, поддерживаемых .NET Core. Исключения — примеры, демонстрирующие возможности или инструменты определенной платформы.

2. Пример должен соответствовать [стилю кодирования corefx](https://github.com/dotnet/corefx/blob/master/Documentation/coding-guidelines/coding-style.md), чтобы не нарушать единообразие.

    - Кроме того, мы предпочитаем использовать методы `static` вместо методов экземпляра при демонстрации кода, который не требует создание экземпляра нового объекта.

3. Ваш пример должен включать **надлежащую обработку исключений**. Он должен обрабатывать все исключения, которые могут возникнуть в контексте примера. Пример, который вызывает метод [Console.ReadLine](https://docs.microsoft.com/dotnet/api/system.console.readline) для извлечения входных данных пользователя, должен использовать надлежащую обработку исключений при передаче входной строки в качестве аргумента в метод. Если пример ожидает сбой вызова метода, он должен обрабатывать полученное исключение. Всегда обрабатывайте конкретные исключения, вызываемые методом, а не исключения базового класса, например [Exception](https://docs.microsoft.com/dotnet/api/system.exception) или [SystemException](https://docs.microsoft.com/dotnet/api/system.systemexception).

4. Если ваш пример компилирует изолированный пакет, включите среды выполнения, используемые нашей системой непрерывной интеграции, в дополнение к средам выполнения, используемым примером:
    - `win7-x64`
    - `win8-x64`
    - `win81-x64`
    - `ubuntu.16.04-x64`

Вскоре у нас будет система непрерывной интеграции для сборки таких проектов.

Создание примера:

1. Отправьте [проблему](https://github.com/dotnet/docs/issues) или напишите комментарий к существующей и сообщите, что вы над ней работаете.
2. Напишите статью, объясняющую концепции, показанные в вашем примере (например: `docs/standard/linq/where-clause.md`).
3. Напишите свой пример (пример: `WhereClause-Sample1.cs`).
4. Создайте файл Program.cs с главной точкой входа, которая вызывает ваши примеры. Если она уже есть, добавьте вызов к вашему примеру:

    ```csharp
    public class Program
    {
        public void Main(string[] args)
        {
            WhereClause1.QuerySyntaxExample();

            // Add the method syntax as an example.
            WhereClause1.MethodSyntaxExample();
        }
    }
    ```

Фрагменты или примеры кода .NET Core создаются в .NET Core CLI, который можно установить с [пакетом SDK для .NET Core](https://www.microsoft.com/net/download). Сборка и запуск примера

1. Перейдите в папку примера и выполните сборку для проверки ошибок:

    ```console
    dotnet build
    ```
2. Запустите пример:

    ```console
    dotnet run
    ```

3. Добавьте файл readme.md в корневой каталог примера. 

   Он должен содержать краткое описание кода и ссылку на статью, к которой относится пример.

Если не указано иное, все примеры компилируются из командной строки на любой платформе, поддерживаемой .NET Core. Некоторые примеры относятся к Visual Studio и требуют Visual Studio 2017 или более поздней версии. Кроме того, некоторые примеры демонстрируют функции конкретной платформы и требуют эту платформу. Другие примеры и фрагменты кода требуют .NET Framework и запускаются на платформах Windows, и им понадобится пакет разработчика для требуемой версии .NET Framework.

## <a name="the-c-interactive-experience"></a>Интерактивный опыт с C#

Все примеры, включенные в статью, указывают на исходный язык с помощью [языковой метки](how-to-write-use-markdown.md#code-snippets). Короткие примеры кода на C# могут содержать метку `csharp-interactive`, чтобы указать на пример C#, выполняемый в браузере. (Для встроенных примеров кода используйте метку `csharp-interactive`. Чтобы указать на фрагменты, включенные из источника, используйте метку `code-csharp-interactive`.) Эти примеры кода отображают окно с кодом и окно вывода в статье. В окне вывода показывается результат выполнения интерактивного кода после запуска примера.

Интерактивный опыт с C# меняет работу с примерами. Читатели могут запустить пример, чтобы увидеть результаты. Определить, должен ли пример или соответствующий текст содержать информацию о выходных данных, можно по нескольким факторам.

### <a name="when-to-display-the-expected-output-without-running-the-sample"></a>Когда отображать ожидаемый результат без запуска примера

- В статьях для начинающих необходимо показывать выходные данные, чтобы читатели могли сравнить результат своей работы с ожидаемым ответом.
- Примеры, в которых выходные данные являются неотъемлемой частью статьи, должны показывать эти выходные данные. Например, в статьях о форматировании текста должен отображаться отформатированный текст без запуска примера.
- Если пример и ожидаемые выходные данные занимают мало места, можно показать выходные данные. Это сэкономит время.
- В статьях, рассказывающих о том, как язык и региональные параметры и инвариантные язык и региональные параметры влияют на результат, выходные данные должны разъясняться. Интерактивный REPL (read–eval–print loop) выполняется на узле на базе Linux. Язык и региональные параметры по умолчанию и инвариантные язык и региональные параметры имеют различные выходные данные в разных операционных системах и на разных компьютерах. В статье должны разъяснятся выходные данные в Windows, Linux и Mac.

### <a name="when-to-exclude-expected-output-from-the-sample"></a>Когда не следует показывать выходные данные примера

- Если выходные данные примера длинные, они не должны приводиться. Это затрудняет понимание кода после запуска примера.
- Если пример в статье демонстрирует тему, но выходные данные не обязательны для понимания. Например, код выполняет запрос LINQ, чтобы объяснить синтаксис запроса, а затем отображает каждый элемент в выходной коллекции.

> [!NOTE]
> Вы можете заметить, что сейчас не все статьи соответствуют представленным здесь рекомендациям. Мы работаем над единообразием сайта. Просмотрите список [открытых проблем](https://github.com/dotnet/docs/issues?q=is%3Aopen+is%3Aissue+label%3A%22%3Abookmark_tabs%3A+Information+Architecture%22), которые мы сейчас отслеживаем, чтобы достичь этой цели.

## <a name="contributor-license-agreement"></a>Лицензионное соглашение с участником

Подпишите [лицензионное соглашение с участником .NET Foundation](https://cla.dotnetfoundation.org) до слияния вашего запроса на вытягивание. При работе над проектами в .NET Foundation это достаточно сделать один раз. Дополнительные сведения о [лицензионных соглашениях с участниками](http://en.wikipedia.org/wiki/Contributor_License_Agreement) читайте в Википедии.

Соглашение: [net-foundation-contribution-license-agreement.pdf](https://github.com/dotnet/home/blob/master/guidance/net-foundation-contribution-license-agreement.pdf)

Не нужно подписывать соглашение заранее. Вы может клонировать, создать вилку и отправить запрос на вытягивание, как обычно. При создании запроса на вытягивание он классифицируется ботом лицензионного соглашения с участником. Если изменение незначительное (например, вы исправили опечатку), запрос на вытягивание помечается тегом `cla-not-required`. В противном случае он классифицируется как `cla-required`. Когда вы подпишете лицензионное соглашение с участником, текущий и все последующие запросы на вытягивание помечаются тегом `cla-signed`.
